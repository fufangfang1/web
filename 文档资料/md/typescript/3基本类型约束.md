## 如何进行类型约束

1. 仅仅需要在变量,函数的参数或者返回值位置加上```:类型```
2. ts在很多场景中可以完成类型推导
3. any: 表示任意类型 对该类型 ts不进行类型检查

## 基本类型

- number string boolean 
- array ```:number[]``` ```:Array<number>```
- object
- null和undefined 是所有其他类型的子类型 它们可以赋值给其他类型
  - 通过配置文件添加```strictNullChecks:true``` 可以获得更严格的空类型检查 null和undefined只能赋值给自身

## 函数的类型约束
函数重载： 在函数实现之前 对函数调用的多种情况进行声明

可选参数:  可以在某些参数后加```？``` 表示该参数不用传递 可选参数必须加载参数列表的末尾

## 扩展类型-枚举

枚举通常用于约束某个变量的取值范围

# 字面量类型的问题

- 在类型约束位置，会产生重复代码 可以使用类型别名解决该问题
- 逻辑含义和真实的值产生混淆，会导致当修改真实值的时候，产生大量修改
- 字面量类型不会进入到编译结果

# 枚举(enum)

如何定义一个枚举:
```
enum 枚举名{
  枚举字段 = 值
}
```

枚举会出现在编译结果中，编译结果中表现为对象

枚举的规则:

- 枚举的字段值可以是字符串或数字
- 数字枚举的值会自动自增
- 被数字枚举约束的变量 可以直接赋值为数字(尽量不用)
- 数字枚举的编译结果 和 字符串枚举 有差异

最佳实现:

- 尽量不要在一个枚举中 即出现字符串字段 又出现数字字段
- 使用枚举时 尽量使用枚举字段的名称 不要使用真实的值

## 扩展知识: 枚举的位运算

针对的数字枚举

位运算: 两个数字换算成二进制后进行的运算

## 模块化

> TS中如何书写模块化语句

> 编译结果？？

## TS中如何书写模块化标准

TS中，导入和导出模块，统一使用ES6的模块化标准

## 编译结果中的模块化(可配置【tsconfig.json】)

TS中的模块化在编译结果中:

- 如果编译结果模块化标准是ES6 没有区别
- 如果编译结果的模块化标准是commonjs 导出的声明会变成exports的属性。默认导出会变成exports的default属性

## 如何在TS中书写CommonJs的代码

- 导出的时候使用export = xxx
- 导入 使用 import xxx = require('xxx')

## 模块解析

> 应该从什么位置寻找模块

- classic：经典 
- node： node解析策略（唯一的变化是将js替换为ts）