# 事件循环

## event loop 解释

> 解释:
> 当宿主环境中的线程发生了某些事情
> 如果该线程发现，这件事情有处理程序，它会将该处理程序加入一个叫做事件队列的内存
> 当 JS 引擎发现 ，执行栈中已经没有了任何内容后，会将事件队列的第一个函数加入到执行栈中执行
> JS 引擎对事件队列的取出执行方式 以及与宿主环境的配合，称为==事件循环==
> JS 运行的环境叫做宿主环境。
> 异步函数的==执行时机==会被宿主环境控制

1. 浏览器宿主环境中包含 5 个线程

- JS 引擎 负责执行执行栈的最顶部代码
- GUI 线程 负责渲染画面
- 事件监听线程 负责监听各种事件
- 计时线程 负责计时
- 网络线程 负责网络通信

> 注意点:JS 引擎和 GUI 线程是互斥的，JS 可以操作 DOM 元素，进而去影响 GUI 的渲染结果，因此是互斥的，也就是说，当 JS 引擎处于运行状态时，GUI 渲染线程将处于冻结状态

## 事件队列分类

- 宏队列： macroTask 计时器结束时的回调 事件回调 http 回调等绝大部分异步函数进入宏队列
- 微任务：MutationObserver Promise 产生的回调进入微队列

> 当执行栈清空时
> JS 引擎首先会将微任务中的所有任务依次执行结束
> 如果没有微任务 则执行宏任务

## 事件和回调函数的缺陷

我们习惯于使用传统的回调或者事件处理来解决异步任务

- 事件：某个对象的属性是一个函数 当发生某一件事时，执行该函数
- 回调： 运行某个函数以实现某个功能的时候，传入一个函数作为参数，当发生某件事情是会运行该函数

> 目前以上方法存在的两个问题

- 回调地狱： 某个异步操作需要等待之前的异步操作完成，无论使用回调还是事件，都会陷入不断的嵌套
- 异步之间的联系：某个异步操作要等待多个异步操作的结果，对这种联系的处理，会让代码复杂度剧增
