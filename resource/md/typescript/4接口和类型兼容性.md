# 扩展类型-接口（interface）

> 扩展类型：类型别名 枚举 接口 类

Ts的接口：用于约束类（主要），对象，函数的契约(标准)

契约(标准)的形式：

- API文档，弱标准
- 代码约束，强标准

>和类型别名一样，接口 不出现在编译结果中

1. 接口约束对象(和类型别名相似)
2. 接口约束函数

**接口可以继承**
可以通过接口之间的继承,实现多种接口的组合

使用类型别名（Type）可以实现相同的组合效果，需要通过```&``` 它们叫做交叉类型

两者的区别:
- 子接口不能覆盖父接口的成员
-  交叉类型会把相同成员的类型进行交叉

**readonly**
只读修饰符：修饰的目标是只读的
只读修饰符不在编译结果中

```
数组只读 一些数组的函数就不能用 比如 pop push 
数组里面的值不可改变
const arr: readonly number[] = [1,2,3]
const arr: ReadonlyArray<number> = [1,2,3]

type User = {
    readonly arr: readonly string[] //地址不能变 并且 数组的值不可变
}
```

# 类型兼容性(重要)

B -> A， 如果能完成赋值 则B和A类型兼容

鸭子辩型法(子结构辩型法):目标类型需要某一些特征，赋值的类型只要能满足某些特征即可

- 基本类型: 完全匹配
- 对象类型: 鸭子辩型法

类型断言 as 关键字

```TS
interface Duck{
    sound:'嘎嘎嘎'
}

{
    sound:'嘎嘎嘎' as '嘎嘎嘎'  //移上去 不是 string 而是 嘎嘎嘎
}
```

**当直接使用对象字面量赋值的时候,会进行更严格的判断**

- 函数类型

**一切无比自然**

**参数**：传递给目标函数的参数可以少但是不可以多

**返回值**: 要求返回什么，必须要返回什么；如果没有返回类型检查，则无所谓