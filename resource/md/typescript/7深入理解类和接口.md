# 面向对象概述

## （TS）为什么要讲面向对象

1. TS为**前端**面向对象开发带来了契机

JS语言没有类型检查，如果使用了面向对象的方式开发，会产生大量的接口，而大量的接口会导致调用复杂度剧增，这种复杂度必须通过严格的类型检查来避免错误，尽管可以使用注释或文档或记忆力，但是他们没有强约束力。

TS带来了完整的类型检查，因此开发复杂程序时，无论接口的数量有多少，都可以获得完整的类型检查，并且这种检查是具有强约束力的。

2. 面向对象中有许多非常成熟的模式，能处理复杂问题

在过去的很多年中，在大型应用或者复杂领域，面向对象已经积累了很多非常多的经验。

nest.js 相当于是前端的**Java Spring**
typeorm：ORM框架 比如:mongoose  类似于**C#的EF**

## 面向对象

Oriented 基于 Object事物 简称 OO

- 是一种编程思想，他提出一切以对象为**切入点**思考问题
     
- 其他编程思想：面向过程(模块化)   函数式编程 
  - 面向过程: 以**功能流程**为思考切入点 不太适合大型项目
  - 函数编程: 以**数学运算**为思考切入点

> 做开发  最重要最难的是**思维**

面向对象: 以划分**类**为思考切入点

类: 可以产生对象的模板

# TS中如何学习

TS中的OOP (面向对象编程)

# 类的继承

## 继承的作用

继承可以描述类与类之间的关系

如果A和B都是类 可以描述为A是B，则A和B形成继承关系

- B是父类 A是子类
- B派生A A继承自B
- B是A的基类，A是B的派生类

如果A继承自B  则A中自动拥有B中的所有成员


## 成员的重写（overload）

子类中覆盖父类的成员

- 子类成员不能改变父类成员的类型
- 无论是属性还是方法 子类都可以对父类的相应成员进行重写，但是重写时，都要保证类型的匹配
- 注意**this**关键字，在继承关系中，this的指向是动态的--调用方法时，根据具体的调用者确定this指向
- super关键字
  - 在子类方法中可以使用super关键字读取父类成员

## 类型匹配

鸭子辩型法

**里氏替换原则**: 子类的对象，始终可以赋值给父类

如果需要判断一个数据的具体子类类型 可以使用 **instanceof** 进行判断

## protected修饰符

> 受保护的成员,只能在自身和子类中访问

在编译结果中没有

## 继承的单根性和传递性

- 单根性: 每个类最多只能拥有一个父亲
- 传递性: 如果A是B的父类 B是C的父类 可以认为A是C的父类

# 抽象类

## 为什么需要抽象类

> 给类前加上```abstract``` 表示该类是一个抽象类

有时，某个类只表示一个抽象概念，主要用于提取子类共有的成员，而不能直接创建它的对象。该类可以作为抽象类

## 抽象成员（属性和方法）

父类中，可能知道有些成员是必须存在的，但是不知道该成员的值或实现是什么。因此，需要有一种强约束，让继承该类的子类必须要实现该成员

> **抽象类**中,可以有抽象成员 在成员前面加上```abstract```,这些抽象成员必须在在子类中实现

## 设计模式 - 模板模式

设计模式:面对一些常见的功能场景，有一些固定的，经过过多年实践的成熟方法，这些方法叫做设计模式。

模板模式:有些方法,所有的子类实现的流程完全一致，只是流程中的某个步骤中的具体实现不一致，这个时候可以将该方法提取到父类，在父类中完成整个流程的实现，遇到实现不一致的方法时，将该方法做成抽象方法。

# 静态成员

静态成员是指附着在类上的成员（属于某个构造函数的成员）

使用```static```修饰的成员属于静态成员

- 实例成员：属于**类创建的对象**的成员
- 静态成员：非实例成员 属于**类**

## 静态方法中的this

- 实例方法中的this指向当前对象
- 静态方法中的this指向**类**

## 设计模式 - 单例模式

单例模式: 某些类的对象，在系统中最多只有一个，为了避免开发者随意创造多个类的对象，进行强约束。

# 再谈接口（interface）

接口用于约束类 对象 函数 是一个类型约束

> 类和接口连用

不使用接口实现时:

- 对成员函数不具有强约束力
- 容易将类型和能力耦合在一起

系统中缺少对能力的定义 -- 接口

面向对象领域中接口的语义：表达了某个类是否拥有某种能力

某个类具有某种能力其实就是实现了某种接口

类型保护函数:通过调用该函数  会触发ts的类型保护 该函数必须返回boolean

``` ts  
export class Lion implements 接口名称{

}

const a = new Lion()

// 判断一个实例是否具有某种能力

// 通过类型保护函数  返回实例是否拥有某种能力
function hasSkill(ani:object):ani is 接口名称{
  if((ani as 接口名称).方法){//类型断言
    return true
  }
  return false
} 
if(hasSkill(a)){//类型保护函数
  a.xxx()
}
```

接口和类型别名的最大区别：接口可以被类实现，类型别名不可以

>接口可以继承类：表示该类的所有成员都在接口中

```ts
class A {
  a1:string = ""
}
class B {
  b1:number = 1
}

interface C extends A , B{ //接口可以继承多个类
  
}

const c:C = {
  //c中必须包含A B中的成员
}

```

# 索引器

```object[值]```  这就是索引器 === 成员表达式

在TS中，默认情况下，不对索引器做严格的类型检查

```noImplicitAny``` 开启对隐式any的检查（tsconfig.json）

```ts
class User{
  // 类的属性是任意类型
  [prop:string]:any //索引器必须书写在最顶部

}
const a = new User()
a['pid']  //不会报错
```

在索引器中，键的类型可以是字符串或者数字

TS中索引器的作品

- 在严格的检查下，可以实现为类动态增加成员
- 可以实现动态的操作类成员

在TS中，如果某个类中使用了两种类型的索引器，要求两种索引器的值类型必须一样。

# this指向约束

## 在JS中this指向的几种情况

明确: 大部分时候，this的指向取决于函数的调用方式

- 如果直接调用函数（全局对象），this指向全局对象或undefined（启用严格模式）
- 如果使用```对象.方法```  this指向对象本身
- 如果是dom事件的处理函数 this指向时间处理对象

特殊情况：

- 箭头函数，this在函数声明时确定指向，指向函数位置的this
- 使用 bind apply call 手动绑定this对象

## TS中使用this

配置```noImplicitThis```  表示不允许this隐式的指向:any

在TS中，允许在书写函数时，手动生命该函数this的指向。将this作为函数的第一个参数，该参数只用于约束this，并不是真正的参数,不会出现在编译结果中。

```ts
interface IUser{

}
function sayHello(this:IUser){

}
```