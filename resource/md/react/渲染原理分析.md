## 渲染原理
渲染：生成用于显示的对象，以及将这些对象形成真实的DOM对象
- React元素
  - React Element,通过React.createElement创建(JSX语法)
  - 组件也是React元素 type(类型)值不同而已
- React节点 
  - 是专门用于渲染到UI界面上的对象 React会通过React元素，创建React节点，ReactDOM一定是通过React节点来进行渲染的
  - 节点类型(一共包含五个节点类型):
  -   1.React DOM节点  创建该节点的React元素类型是一个字符串
  -   2.React 组件节点：创建该节点React元素类型是一个函数或者是一个类
  -   3.React TextNode节点 由字符串，数字创建
  -   4.React Empty (空)节点 会形成占位 不会形成真实dom元素 由null undefined false  true 来创建的的空节点
  -   5.React数组节点：由一个数组创建 会形成占位 数组每一个节点要加key值，不然会形成警告
- 最终是把节点渲染到UI界面
- 真实DOM (通过document.createElement创建的dom元素)

## 首次渲染(新节点渲染)
1. 通过参数的值创建节点 
2. 根据不同的节点做不同的事情
   1. 文本节点，通过document.createTextNode()创建真实的文本节点
   2. 空节点 什么也不做
   3. 数组节点：遍历数组，将数组每一项递归(**深度优先**)创建节点(回到第一步进行反复操作，直到结束)
   4. DOM节点  通过document.createElement创建真实的DOM对象，然后立即设置该真实DOM元素的各种属性，然后遍历对应React元素的children，递归操作
   5. 组件节点
      1. 函数组件节点 调用函数(传递属性props)(该函数必须返回一个可以生成节点的内容) 
      2. 类组件：会创建该类的实例对象，立即调用对象的生命周期方法(static getDerivedStateFromProps)，运行该对象的render方法,拿到节点对象(递归操作),将该组件的componentDidMount加入到执行队列(先进先出,先进先执行)，当整个虚拟DOM树全部构建完毕，并且将真实的DOM元素加入到容器中，才会执行该队列
3. 生成虚拟DOM树之后，将该树保存起来，以便后续使用
4. 将之前生成的真实DOM对象加入到容器中
**React节点形成虚拟DOM树**

## 更新节点
>场景
1. 重新调用ReactDOM.render()  触发根节点更新
2. 在类组件的实例对象中调用setState，会导致该实力所在的节点更新
**节点的更新**
- 如果调用的是ReactDOM.render，进入根节点的对比(diff)更新
- 如果调用的是setState
  - 1.运行生命周期函数，static getDerivedStateFromProps
  - 2.运行shouldComponentUpdate 如果返回false 终止当前流程。
  - 3.运行render  得到一个新的节点，进入该新的节点的**对比更新**
  - 4.将生命周期函数getSnapshotBeforeUpdate加入执行队列，以待将来执行
  - 5.将生命周期函数componentDidUpdate加入执行队列，以待将来执行

后续步骤: 两种方法都要做的
1. 更新虚拟DOM树
2. 完成真实DOM更新
3. 依此调用执行队列中的componentDidMount
4. 依此调用执行队列中的getSnapshotBeforeUpdate
5. 依此调用执行队列中的componentDidUpdate

**对比更新**
将新产生的节点，对比之前虚拟DOM中的节点，发现差异，完成更新。
>问题：对比之前DOM树中的哪个节点
React为了提高对比效率，做出以下假设
1. 假设节点不会出现层级的移动(对比时直接找到旧树中对应位置节点进行对比)
2. 不同的节点类型会生成不同的结构
   1. 相同的节点类型:节点本身类型相同，如果是由React元素生成，type值必须一致，如果是组件类型，组件类型也必须一致
   2. 其他的，都属于不同的节点类型
3. 多个兄弟节点通过唯一标识(key)来确定对比的新节点

**key**值的作用：用于通过旧节点，寻找对应的新节点，如果某个旧的节点有key值，则其更新时，会寻找相同层级中的相同key值的节点，进行对比
**key**值应该在一个范围内唯一(兄弟节点中) ，并且应该保持稳定

>找到了对比的目标
- 判断节点类型是否一致
  - 一致的话
1. 根据不同的节点类型，做不同的事情
   1.空节点： 不做任何事情
   2.DOM节点
     1. 直接重用之前的真实DOM对象
     2. 将其属性的变化记录下来，以待将来统一完成更新(现在不会真正进行变化)
     3. 遍历该新的React元素的子元素，**递归对比更新**
   1. 文本节点
     1.直接重用之前的真实DOM对象
     2.记录变化的nodeValue  将来统一进行更新
   2. 组件节点
     1. 函数组件
        1.直接重新调用函数，得到一个节点对象，进入递归对比更新
     2.类组件
        1.重用之前的实例
        2.调用生命周期方法getDerivedStateFromProps
        3.调用生命周期方法shouldComponentUpdate 返回fasle 终止
        4.运行render 新的节点对象，进入**递归对比更新**
        5.将该对象的getSnapshotBeforeUpdate加入队列
        6.将该对象的componentDidUpdate加入队列
    5.数组节点
      1.遍历数组。进行**递归对比更新**
  - 不一致
整体上，创建全新的节点，卸载旧的节点
**先创建新节点**
进入**首次渲染**的流程

**再卸载旧节点**
1. **文本节点 dom节点 数组节点 空节点 函数组件节点** 直接放弃该节点，如果节点有子节点，递归卸载子节点
2. 如果节点是类组件节点
   1.直接放弃该节点
   2.调用该节点的componentWillUnMount
   3.递归卸载子节点
>没有找到了对比的目标
新的DOM树中有节点被删除
新的DOM树中有节点添加
- 创建新加入的节点  首次渲染
- 卸载多余的节点    卸载旧节点流程






